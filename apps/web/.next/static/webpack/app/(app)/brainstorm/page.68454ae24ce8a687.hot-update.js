"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(app)/brainstorm/page",{

/***/ "(app-pages-browser)/./lib/brainstorm/state.ts":
/*!*********************************!*\
  !*** ./lib/brainstorm/state.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useBrainstormState: function() { return /* binding */ useBrainstormState; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst STORAGE_KEY = \"brainstorm_state\";\nconst SESSIONS_KEY = \"brainstorm_sessions\";\n// Initialize default state\nconst createInitialState = ()=>({\n        suggestions: [],\n        sessionId: \"session_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9)),\n        startedAt: new Date(),\n        lastUpdated: new Date(),\n        metadata: {\n            totalSuggestions: 0,\n            acceptedCount: 0,\n            rejectedCount: 0,\n            deferredCount: 0,\n            categories: {}\n        }\n    });\n// Calculate metadata from suggestions\nconst calculateMetadata = (suggestions)=>{\n    const metadata = {\n        totalSuggestions: suggestions.length,\n        acceptedCount: 0,\n        rejectedCount: 0,\n        deferredCount: 0,\n        categories: {}\n    };\n    suggestions.forEach((suggestion)=>{\n        // Count decisions\n        if (suggestion.decision === \"accepted\") metadata.acceptedCount++;\n        else if (suggestion.decision === \"rejected\") metadata.rejectedCount++;\n        else if (suggestion.decision === \"deferred\") metadata.deferredCount++;\n        // Count categories\n        metadata.categories[suggestion.category] = (metadata.categories[suggestion.category] || 0) + 1;\n    });\n    return metadata;\n};\n// Save state to localStorage\nconst saveState = (state)=>{\n    try {\n        const serialized = {\n            ...state,\n            startedAt: state.startedAt.toISOString(),\n            lastUpdated: state.lastUpdated.toISOString(),\n            suggestions: state.suggestions.map((s)=>({\n                    ...s,\n                    created_at: s.created_at.toISOString()\n                }))\n        };\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(serialized));\n    } catch (error) {\n        console.error(\"Failed to save brainstorm state:\", error);\n    }\n};\n// Load state from localStorage\nconst loadState = ()=>{\n    try {\n        const saved = localStorage.getItem(STORAGE_KEY);\n        if (!saved) return createInitialState();\n        const parsed = JSON.parse(saved);\n        return {\n            ...parsed,\n            startedAt: new Date(parsed.startedAt),\n            lastUpdated: new Date(parsed.lastUpdated),\n            suggestions: parsed.suggestions.map((s)=>({\n                    ...s,\n                    created_at: new Date(s.created_at)\n                }))\n        };\n    } catch (error) {\n        console.error(\"Failed to load brainstorm state:\", error);\n        return createInitialState();\n    }\n};\n// Save session to history\nconst saveSession = (session)=>{\n    try {\n        const sessions = loadSessions();\n        const existingIndex = sessions.findIndex((s)=>s.id === session.id);\n        if (existingIndex >= 0) {\n            sessions[existingIndex] = session;\n        } else {\n            sessions.push(session);\n        }\n        // Keep only last 10 sessions\n        const recentSessions = sessions.slice(-10);\n        localStorage.setItem(SESSIONS_KEY, JSON.stringify(recentSessions));\n    } catch (error) {\n        console.error(\"Failed to save session:\", error);\n    }\n};\n// Load sessions from history\nconst loadSessions = ()=>{\n    try {\n        const saved = localStorage.getItem(SESSIONS_KEY);\n        if (!saved) return [];\n        const parsed = JSON.parse(saved);\n        return parsed.map((session)=>({\n                ...session,\n                state: {\n                    ...session.state,\n                    startedAt: new Date(session.state.startedAt),\n                    lastUpdated: new Date(session.state.lastUpdated),\n                    suggestions: session.state.suggestions.map((s)=>({\n                            ...s,\n                            created_at: new Date(s.created_at)\n                        }))\n                },\n                exportedAt: session.exportedAt ? new Date(session.exportedAt) : undefined\n            }));\n    } catch (error) {\n        console.error(\"Failed to load sessions:\", error);\n        return [];\n    }\n};\n// Sync state with Supabase (if authenticated)\nconst syncWithSupabase = async (state)=>{\n    try {\n        const response = await fetch(\"/api/brainstorm/sync\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify(state)\n        });\n        if (!response.ok) {\n            console.warn(\"Failed to sync with Supabase:\", response.statusText);\n        }\n    } catch (error) {\n        console.warn(\"Supabase sync failed:\", error);\n    // Continue with local storage only\n    }\n};\n// Custom hook for brainstorm state management\nconst useBrainstormState = ()=>{\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(createInitialState);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);\n    // Load initial state\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const loadedState = loadState();\n        setState(loadedState);\n        setIsLoading(false);\n    }, []);\n    // Update state and persist\n    const updateState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((updater)=>{\n        setState((prev)=>{\n            const newState = updater(prev);\n            const stateWithMetadata = {\n                ...newState,\n                lastUpdated: new Date(),\n                metadata: calculateMetadata(newState.suggestions)\n            };\n            // Save to localStorage\n            saveState(stateWithMetadata);\n            // Sync with Supabase (async, non-blocking)\n            syncWithSupabase(stateWithMetadata);\n            return stateWithMetadata;\n        });\n    }, []);\n    // Add a new suggestion\n    const addSuggestion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((suggestion)=>{\n        updateState((prev)=>({\n                ...prev,\n                suggestions: [\n                    ...prev.suggestions,\n                    {\n                        ...suggestion,\n                        id: \"suggestion_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9)),\n                        decision: \"pending\"\n                    }\n                ]\n            }));\n    }, [\n        updateState\n    ]);\n    // Update suggestion decision\n    const updateDecision = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id, decision, notes)=>{\n        updateState((prev)=>({\n                ...prev,\n                suggestions: prev.suggestions.map((s)=>s.id === id ? {\n                        ...s,\n                        decision,\n                        notes: notes || s.notes\n                    } : s)\n            }));\n    }, [\n        updateState\n    ]);\n    // Update suggestion\n    const updateSuggestion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id, updates)=>{\n        updateState((prev)=>({\n                ...prev,\n                suggestions: prev.suggestions.map((s)=>s.id === id ? {\n                        ...s,\n                        ...updates\n                    } : s)\n            }));\n    }, [\n        updateState\n    ]);\n    // Remove suggestion\n    const removeSuggestion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id)=>{\n        updateState((prev)=>({\n                ...prev,\n                suggestions: prev.suggestions.filter((s)=>s.id !== id)\n            }));\n    }, [\n        updateState\n    ]);\n    // Clear all suggestions\n    const clearSuggestions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        updateState((prev)=>({\n                ...prev,\n                suggestions: []\n            }));\n    }, [\n        updateState\n    ]);\n    // Reset to new session\n    const startNewSession = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        // Save current session to history\n        const currentSession = {\n            id: state.sessionId,\n            state,\n            conversationHistory: []\n        };\n        saveSession(currentSession);\n        // Create new session\n        const newState = createInitialState();\n        setState(newState);\n        saveState(newState);\n    }, [\n        state\n    ]);\n    // Load a previous session\n    const loadSession = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((sessionId)=>{\n        const sessions = loadSessions();\n        const session = sessions.find((s)=>s.id === sessionId);\n        if (session) {\n            setState(session.state);\n            saveState(session.state);\n        }\n    }, []);\n    // Export current state as markdown\n    const exportHistory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        const { suggestions, sessionId, startedAt, metadata } = state;\n        let markdown = \"# Brainstorm Session Report\\n\\n\";\n        markdown += \"**Session ID:** \".concat(sessionId, \"\\n\");\n        markdown += \"**Started:** \".concat(startedAt.toLocaleString(), \"\\n\");\n        markdown += \"**Last Updated:** \".concat(state.lastUpdated.toLocaleString(), \"\\n\\n\");\n        // Summary\n        markdown += \"## Summary\\n\\n\";\n        markdown += \"- **Total Suggestions:** \".concat(metadata.totalSuggestions, \"\\n\");\n        markdown += \"- **Accepted:** \".concat(metadata.acceptedCount, \"\\n\");\n        markdown += \"- **Rejected:** \".concat(metadata.rejectedCount, \"\\n\");\n        markdown += \"- **Deferred:** \".concat(metadata.deferredCount, \"\\n\");\n        markdown += \"- **Pending:** \".concat(metadata.totalSuggestions - metadata.acceptedCount - metadata.rejectedCount - metadata.deferredCount, \"\\n\\n\");\n        // Categories breakdown\n        markdown += \"### Categories\\n\\n\";\n        Object.entries(metadata.categories).forEach((param)=>{\n            let [category, count] = param;\n            markdown += \"- **\".concat(category.charAt(0).toUpperCase() + category.slice(1), \":** \").concat(count, \"\\n\");\n        });\n        markdown += \"\\n\";\n        // Decisions table\n        markdown += \"## Decisions\\n\\n\";\n        markdown += \"| Title | Category | Decision | Impact | Confidence | Effort | Notes |\\n\";\n        markdown += \"|-------|----------|----------|--------|------------|--------|-------|\\n\";\n        suggestions.forEach((suggestion)=>{\n            const decision = suggestion.decision || \"pending\";\n            const notes = suggestion.notes ? suggestion.notes.replace(/\\n/g, \" \").substring(0, 50) + \"...\" : \"\";\n            markdown += \"| \".concat(suggestion.title, \" | \").concat(suggestion.category, \" | \").concat(decision, \" | \").concat(suggestion.impact_score, \"/10 | \").concat(Math.round(suggestion.confidence * 100), \"% | \").concat(suggestion.implementation_effort, \" | \").concat(notes, \" |\\n\");\n        });\n        markdown += \"\\n\";\n        // Accepted suggestions detail\n        const accepted = suggestions.filter((s)=>s.decision === \"accepted\");\n        if (accepted.length > 0) {\n            markdown += \"## Accepted Suggestions\\n\\n\";\n            accepted.forEach((suggestion, index)=>{\n                markdown += \"### \".concat(index + 1, \". \").concat(suggestion.title, \"\\n\\n\");\n                markdown += \"**Category:** \".concat(suggestion.category, \"\\n\");\n                markdown += \"**Impact Score:** \".concat(suggestion.impact_score, \"/10\\n\");\n                markdown += \"**Confidence:** \".concat(Math.round(suggestion.confidence * 100), \"%\\n\");\n                markdown += \"**Implementation Effort:** \".concat(suggestion.implementation_effort, \"\\n\\n\");\n                markdown += \"**Summary:** \".concat(suggestion.summary, \"\\n\\n\");\n                markdown += \"**Reasoning:** \".concat(suggestion.reasoning, \"\\n\\n\");\n                if (suggestion.dependencies && suggestion.dependencies.length > 0) {\n                    markdown += \"**Dependencies:**\\n\";\n                    suggestion.dependencies.forEach((dep)=>{\n                        markdown += \"- \".concat(dep, \"\\n\");\n                    });\n                    markdown += \"\\n\";\n                }\n                if (suggestion.metrics && suggestion.metrics.length > 0) {\n                    markdown += \"**Success Metrics:**\\n\";\n                    suggestion.metrics.forEach((metric)=>{\n                        markdown += \"- \".concat(metric, \"\\n\");\n                    });\n                    markdown += \"\\n\";\n                }\n                if (suggestion.risks && suggestion.risks.length > 0) {\n                    markdown += \"**Risks:**\\n\";\n                    suggestion.risks.forEach((risk)=>{\n                        markdown += \"- \".concat(risk, \"\\n\");\n                    });\n                    markdown += \"\\n\";\n                }\n                if (suggestion.notes) {\n                    markdown += \"**Notes:** \".concat(suggestion.notes, \"\\n\\n\");\n                }\n                markdown += \"---\\n\\n\";\n            });\n        }\n        // Mark session as exported\n        updateState((prev)=>prev);\n        const session = {\n            id: sessionId,\n            state,\n            conversationHistory: [],\n            exportedAt: new Date()\n        };\n        saveSession(session);\n        return markdown;\n    }, [\n        state,\n        updateState\n    ]);\n    // Get filtered suggestions\n    const getFilteredSuggestions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((filters)=>{\n        return state.suggestions.filter((suggestion)=>{\n            if (filters.category && suggestion.category !== filters.category) return false;\n            if (filters.decision && suggestion.decision !== filters.decision) return false;\n            if (filters.minImpact && suggestion.impact_score < filters.minImpact) return false;\n            if (filters.maxImpact && suggestion.impact_score > filters.maxImpact) return false;\n            return true;\n        });\n    }, [\n        state.suggestions\n    ]);\n    // Get session history\n    const getSessionHistory = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        return loadSessions();\n    }, []);\n    return {\n        state,\n        isLoading,\n        addSuggestion,\n        updateDecision,\n        updateSuggestion,\n        removeSuggestion,\n        clearSuggestions,\n        startNewSession,\n        loadSession,\n        exportHistory,\n        getFilteredSuggestions,\n        getSessionHistory\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9icmFpbnN0b3JtL3N0YXRlLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5RDtBQXdCekQsTUFBTUcsY0FBYztBQUNwQixNQUFNQyxlQUFlO0FBRXJCLDJCQUEyQjtBQUMzQixNQUFNQyxxQkFBcUIsSUFBd0I7UUFDakRDLGFBQWEsRUFBRTtRQUNmQyxXQUFXLFdBQXlCQyxPQUFkQyxLQUFLQyxHQUFHLElBQUcsS0FBMkMsT0FBeENGLEtBQUtHLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLE1BQU0sQ0FBQyxHQUFHO1FBQ3pFQyxXQUFXLElBQUlMO1FBQ2ZNLGFBQWEsSUFBSU47UUFDakJPLFVBQVU7WUFDUkMsa0JBQWtCO1lBQ2xCQyxlQUFlO1lBQ2ZDLGVBQWU7WUFDZkMsZUFBZTtZQUNmQyxZQUFZLENBQUM7UUFDZjtJQUNGO0FBRUEsc0NBQXNDO0FBQ3RDLE1BQU1DLG9CQUFvQixDQUFDaEI7SUFDekIsTUFBTVUsV0FBVztRQUNmQyxrQkFBa0JYLFlBQVlpQixNQUFNO1FBQ3BDTCxlQUFlO1FBQ2ZDLGVBQWU7UUFDZkMsZUFBZTtRQUNmQyxZQUFZLENBQUM7SUFDZjtJQUVBZixZQUFZa0IsT0FBTyxDQUFDLENBQUNDO1FBQ25CLGtCQUFrQjtRQUNsQixJQUFJQSxXQUFXQyxRQUFRLEtBQUssWUFBWVYsU0FBU0UsYUFBYTthQUN6RCxJQUFJTyxXQUFXQyxRQUFRLEtBQUssWUFBWVYsU0FBU0csYUFBYTthQUM5RCxJQUFJTSxXQUFXQyxRQUFRLEtBQUssWUFBWVYsU0FBU0ksYUFBYTtRQUVuRSxtQkFBbUI7UUFDbkJKLFNBQVNLLFVBQVUsQ0FBQ0ksV0FBV0UsUUFBUSxDQUFDLEdBQUcsQ0FBQ1gsU0FBU0ssVUFBVSxDQUFDSSxXQUFXRSxRQUFRLENBQUMsSUFBSSxLQUFLO0lBQy9GO0lBRUEsT0FBT1g7QUFDVDtBQUVBLDZCQUE2QjtBQUM3QixNQUFNWSxZQUFZLENBQUNDO0lBQ2pCLElBQUk7UUFDRixNQUFN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SUFBSTdGLFdBQVc0RSxZQUFZLEdBQUdlLFFBQVFFLFNBQVMsRUFBRSxPQUFPO1lBQzdFLE9BQU87UUFDVDtJQUNGLEdBQUc7UUFBQ3pGLE1BQU12QixXQUFXO0tBQUM7SUFFdEIsc0JBQXNCO0lBQ3RCLE1BQU1pSCxvQkFBb0JySCxrREFBV0EsQ0FBQztRQUNwQyxPQUFPK0M7SUFDVCxHQUFHLEVBQUU7SUFFTCxPQUFPO1FBQ0xwQjtRQUNBd0M7UUFDQVE7UUFDQUM7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUM7UUFDQUc7UUFDQUU7UUFDQXlCO1FBQ0FJO0lBQ0Y7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9icmFpbnN0b3JtL3N0YXRlLnRzPzUxZjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBTdWdnZXN0aW9uQ2FyZERhdGEgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL2JyYWluc3Rvcm0vQ2FyZCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnJhaW5zdG9ybVN0YXRlIHtcbiAgc3VnZ2VzdGlvbnM6IFN1Z2dlc3Rpb25DYXJkRGF0YVtdO1xuICBzZXNzaW9uSWQ6IHN0cmluZztcbiAgc3RhcnRlZEF0OiBEYXRlO1xuICBsYXN0VXBkYXRlZDogRGF0ZTtcbiAgbWV0YWRhdGE6IHtcbiAgICB0b3RhbFN1Z2dlc3Rpb25zOiBudW1iZXI7XG4gICAgYWNjZXB0ZWRDb3VudDogbnVtYmVyO1xuICAgIHJlamVjdGVkQ291bnQ6IG51bWJlcjtcbiAgICBkZWZlcnJlZENvdW50OiBudW1iZXI7XG4gICAgY2F0ZWdvcmllczogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCcmFpbnN0b3JtU2Vzc2lvbiB7XG4gIGlkOiBzdHJpbmc7XG4gIHN0YXRlOiBCcmFpbnN0b3JtU3RhdGU7XG4gIGNvbnZlcnNhdGlvbkhpc3Rvcnk6IGFueVtdO1xuICBleHBvcnRlZEF0PzogRGF0ZTtcbn1cblxuY29uc3QgU1RPUkFHRV9LRVkgPSAnYnJhaW5zdG9ybV9zdGF0ZSc7XG5jb25zdCBTRVNTSU9OU19LRVkgPSAnYnJhaW5zdG9ybV9zZXNzaW9ucyc7XG5cbi8vIEluaXRpYWxpemUgZGVmYXVsdCBzdGF0ZVxuY29uc3QgY3JlYXRlSW5pdGlhbFN0YXRlID0gKCk6IEJyYWluc3Rvcm1TdGF0ZSA9PiAoe1xuICBzdWdnZXN0aW9uczogW10sXG4gIHNlc3Npb25JZDogYHNlc3Npb25fJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gLFxuICBzdGFydGVkQXQ6IG5ldyBEYXRlKCksXG4gIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLFxuICBtZXRhZGF0YToge1xuICAgIHRvdGFsU3VnZ2VzdGlvbnM6IDAsXG4gICAgYWNjZXB0ZWRDb3VudDogMCxcbiAgICByZWplY3RlZENvdW50OiAwLFxuICAgIGRlZmVycmVkQ291bnQ6IDAsXG4gICAgY2F0ZWdvcmllczoge30sXG4gIH0sXG59KTtcblxuLy8gQ2FsY3VsYXRlIG1ldGFkYXRhIGZyb20gc3VnZ2VzdGlvbnNcbmNvbnN0IGNhbGN1bGF0ZU1ldGFkYXRhID0gKHN1Z2dlc3Rpb25zOiBTdWdnZXN0aW9uQ2FyZERhdGFbXSkgPT4ge1xuICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICB0b3RhbFN1Z2dlc3Rpb25zOiBzdWdnZXN0aW9ucy5sZW5ndGgsXG4gICAgYWNjZXB0ZWRDb3VudDogMCxcbiAgICByZWplY3RlZENvdW50OiAwLFxuICAgIGRlZmVycmVkQ291bnQ6IDAsXG4gICAgY2F0ZWdvcmllczoge30gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPixcbiAgfTtcblxuICBzdWdnZXN0aW9ucy5mb3JFYWNoKChzdWdnZXN0aW9uKSA9PiB7XG4gICAgLy8gQ291bnQgZGVjaXNpb25zXG4gICAgaWYgKHN1Z2dlc3Rpb24uZGVjaXNpb24gPT09ICdhY2NlcHRlZCcpIG1ldGFkYXRhLmFjY2VwdGVkQ291bnQrKztcbiAgICBlbHNlIGlmIChzdWdnZXN0aW9uLmRlY2lzaW9uID09PSAncmVqZWN0ZWQnKSBtZXRhZGF0YS5yZWplY3RlZENvdW50Kys7XG4gICAgZWxzZSBpZiAoc3VnZ2VzdGlvbi5kZWNpc2lvbiA9PT0gJ2RlZmVycmVkJykgbWV0YWRhdGEuZGVmZXJyZWRDb3VudCsrO1xuXG4gICAgLy8gQ291bnQgY2F0ZWdvcmllc1xuICAgIG1ldGFkYXRhLmNhdGVnb3JpZXNbc3VnZ2VzdGlvbi5jYXRlZ29yeV0gPSAobWV0YWRhdGEuY2F0ZWdvcmllc1tzdWdnZXN0aW9uLmNhdGVnb3J5XSB8fCAwKSArIDE7XG4gIH0pO1xuXG4gIHJldHVybiBtZXRhZGF0YTtcbn07XG5cbi8vIFNhdmUgc3RhdGUgdG8gbG9jYWxTdG9yYWdlXG5jb25zdCBzYXZlU3RhdGUgPSAoc3RhdGU6IEJyYWluc3Rvcm1TdGF0ZSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICAuLi5zdGF0ZSxcbiAgICAgIHN0YXJ0ZWRBdDogc3RhdGUuc3RhcnRlZEF0LnRvSVNPU3RyaW5nKCksXG4gICAgICBsYXN0VXBkYXRlZDogc3RhdGUubGFzdFVwZGF0ZWQudG9JU09TdHJpbmcoKSxcbiAgICAgIHN1Z2dlc3Rpb25zOiBzdGF0ZS5zdWdnZXN0aW9ucy5tYXAocyA9PiAoe1xuICAgICAgICAuLi5zLFxuICAgICAgICBjcmVhdGVkX2F0OiBzLmNyZWF0ZWRfYXQudG9JU09TdHJpbmcoKSxcbiAgICAgIH0pKSxcbiAgICB9O1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShzZXJpYWxpemVkKSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNhdmUgYnJhaW5zdG9ybSBzdGF0ZTonLCBlcnJvcik7XG4gIH1cbn07XG5cbi8vIExvYWQgc3RhdGUgZnJvbSBsb2NhbFN0b3JhZ2VcbmNvbnN0IGxvYWRTdGF0ZSA9ICgpOiBCcmFpbnN0b3JtU3RhdGUgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHNhdmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oU1RPUkFHRV9LRVkpO1xuICAgIGlmICghc2F2ZWQpIHJldHVybiBjcmVhdGVJbml0aWFsU3RhdGUoKTtcblxuICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2Uoc2F2ZWQpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5wYXJzZWQsXG4gICAgICBzdGFydGVkQXQ6IG5ldyBEYXRlKHBhcnNlZC5zdGFydGVkQXQpLFxuICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKHBhcnNlZC5sYXN0VXBkYXRlZCksXG4gICAgICBzdWdnZXN0aW9uczogcGFyc2VkLnN1Z2dlc3Rpb25zLm1hcCgoczogYW55KSA9PiAoe1xuICAgICAgICAuLi5zLFxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZShzLmNyZWF0ZWRfYXQpLFxuICAgICAgfSkpLFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgYnJhaW5zdG9ybSBzdGF0ZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIGNyZWF0ZUluaXRpYWxTdGF0ZSgpO1xuICB9XG59O1xuXG4vLyBTYXZlIHNlc3Npb24gdG8gaGlzdG9yeVxuY29uc3Qgc2F2ZVNlc3Npb24gPSAoc2Vzc2lvbjogQnJhaW5zdG9ybVNlc3Npb24pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzZXNzaW9ucyA9IGxvYWRTZXNzaW9ucygpO1xuICAgIGNvbnN0IGV4aXN0aW5nSW5kZXggPSBzZXNzaW9ucy5maW5kSW5kZXgocyA9PiBzLmlkID09PSBzZXNzaW9uLmlkKTtcbiAgICBcbiAgICBpZiAoZXhpc3RpbmdJbmRleCA+PSAwKSB7XG4gICAgICBzZXNzaW9uc1tleGlzdGluZ0luZGV4XSA9IHNlc3Npb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlc3Npb25zLnB1c2goc2Vzc2lvbik7XG4gICAgfVxuXG4gICAgLy8gS2VlcCBvbmx5IGxhc3QgMTAgc2Vzc2lvbnNcbiAgICBjb25zdCByZWNlbnRTZXNzaW9ucyA9IHNlc3Npb25zLnNsaWNlKC0xMCk7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU0VTU0lPTlNfS0VZLCBKU09OLnN0cmluZ2lmeShyZWNlbnRTZXNzaW9ucykpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIHNlc3Npb246JywgZXJyb3IpO1xuICB9XG59O1xuXG4vLyBMb2FkIHNlc3Npb25zIGZyb20gaGlzdG9yeVxuY29uc3QgbG9hZFNlc3Npb25zID0gKCk6IEJyYWluc3Rvcm1TZXNzaW9uW10gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHNhdmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oU0VTU0lPTlNfS0VZKTtcbiAgICBpZiAoIXNhdmVkKSByZXR1cm4gW107XG5cbiAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHNhdmVkKTtcbiAgICByZXR1cm4gcGFyc2VkLm1hcCgoc2Vzc2lvbjogYW55KSA9PiAoe1xuICAgICAgLi4uc2Vzc2lvbixcbiAgICAgIHN0YXRlOiB7XG4gICAgICAgIC4uLnNlc3Npb24uc3RhdGUsXG4gICAgICAgIHN0YXJ0ZWRBdDogbmV3IERhdGUoc2Vzc2lvbi5zdGF0ZS5zdGFydGVkQXQpLFxuICAgICAgICBsYXN0VXBkYXRlZDogbmV3IERhdGUoc2Vzc2lvbi5zdGF0ZS5sYXN0VXBkYXRlZCksXG4gICAgICAgIHN1Z2dlc3Rpb25zOiBzZXNzaW9uLnN0YXRlLnN1Z2dlc3Rpb25zLm1hcCgoczogYW55KSA9PiAoe1xuICAgICAgICAgIC4uLnMsXG4gICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUocy5jcmVhdGVkX2F0KSxcbiAgICAgICAgfSkpLFxuICAgICAgfSxcbiAgICAgIGV4cG9ydGVkQXQ6IHNlc3Npb24uZXhwb3J0ZWRBdCA/IG5ldyBEYXRlKHNlc3Npb24uZXhwb3J0ZWRBdCkgOiB1bmRlZmluZWQsXG4gICAgfSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIHNlc3Npb25zOicsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbi8vIFN5bmMgc3RhdGUgd2l0aCBTdXBhYmFzZSAoaWYgYXV0aGVudGljYXRlZClcbmNvbnN0IHN5bmNXaXRoU3VwYWJhc2UgPSBhc3luYyAoc3RhdGU6IEJyYWluc3Rvcm1TdGF0ZSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvYnJhaW5zdG9ybS9zeW5jJywge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoc3RhdGUpLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc3luYyB3aXRoIFN1cGFiYXNlOicsIHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLndhcm4oJ1N1cGFiYXNlIHN5bmMgZmFpbGVkOicsIGVycm9yKTtcbiAgICAvLyBDb250aW51ZSB3aXRoIGxvY2FsIHN0b3JhZ2Ugb25seVxuICB9XG59O1xuXG4vLyBDdXN0b20gaG9vayBmb3IgYnJhaW5zdG9ybSBzdGF0ZSBtYW5hZ2VtZW50XG5leHBvcnQgY29uc3QgdXNlQnJhaW5zdG9ybVN0YXRlID0gKCkgPT4ge1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlPEJyYWluc3Rvcm1TdGF0ZT4oY3JlYXRlSW5pdGlhbFN0YXRlKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuXG4gIC8vIExvYWQgaW5pdGlhbCBzdGF0ZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGxvYWRlZFN0YXRlID0gbG9hZFN0YXRlKCk7XG4gICAgc2V0U3RhdGUobG9hZGVkU3RhdGUpO1xuICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gIH0sIFtdKTtcblxuICAvLyBVcGRhdGUgc3RhdGUgYW5kIHBlcnNpc3RcbiAgY29uc3QgdXBkYXRlU3RhdGUgPSB1c2VDYWxsYmFjaygodXBkYXRlcjogKHByZXY6IEJyYWluc3Rvcm1TdGF0ZSkgPT4gQnJhaW5zdG9ybVN0YXRlKSA9PiB7XG4gICAgc2V0U3RhdGUocHJldiA9PiB7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHVwZGF0ZXIocHJldik7XG4gICAgICBjb25zdCBzdGF0ZVdpdGhNZXRhZGF0YSA9IHtcbiAgICAgICAgLi4ubmV3U3RhdGUsXG4gICAgICAgIGxhc3RVcGRhdGVkOiBuZXcgRGF0ZSgpLFxuICAgICAgICBtZXRhZGF0YTogY2FsY3VsYXRlTWV0YWRhdGEobmV3U3RhdGUuc3VnZ2VzdGlvbnMpLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gU2F2ZSB0byBsb2NhbFN0b3JhZ2VcbiAgICAgIHNhdmVTdGF0ZShzdGF0ZVdpdGhNZXRhZGF0YSk7XG4gICAgICBcbiAgICAgIC8vIFN5bmMgd2l0aCBTdXBhYmFzZSAoYXN5bmMsIG5vbi1ibG9ja2luZylcbiAgICAgIHN5bmNXaXRoU3VwYWJhc2Uoc3RhdGVXaXRoTWV0YWRhdGEpO1xuICAgICAgXG4gICAgICByZXR1cm4gc3RhdGVXaXRoTWV0YWRhdGE7XG4gICAgfSk7XG4gIH0sIFtdKTtcblxuICAvLyBBZGQgYSBuZXcgc3VnZ2VzdGlvblxuICBjb25zdCBhZGRTdWdnZXN0aW9uID0gdXNlQ2FsbGJhY2soKHN1Z2dlc3Rpb246IE9taXQ8U3VnZ2VzdGlvbkNhcmREYXRhLCAnaWQnPikgPT4ge1xuICAgIHVwZGF0ZVN0YXRlKHByZXYgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICBzdWdnZXN0aW9uczogW1xuICAgICAgICAuLi5wcmV2LnN1Z2dlc3Rpb25zLFxuICAgICAgICB7XG4gICAgICAgICAgLi4uc3VnZ2VzdGlvbixcbiAgICAgICAgICBpZDogYHN1Z2dlc3Rpb25fJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gLFxuICAgICAgICAgIGRlY2lzaW9uOiAncGVuZGluZycgYXMgY29uc3QsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0pKTtcbiAgfSwgW3VwZGF0ZVN0YXRlXSk7XG5cbiAgLy8gVXBkYXRlIHN1Z2dlc3Rpb24gZGVjaXNpb25cbiAgY29uc3QgdXBkYXRlRGVjaXNpb24gPSB1c2VDYWxsYmFjaygoaWQ6IHN0cmluZywgZGVjaXNpb246ICdhY2NlcHRlZCcgfCAncmVqZWN0ZWQnIHwgJ2RlZmVycmVkJywgbm90ZXM/OiBzdHJpbmcpID0+IHtcbiAgICB1cGRhdGVTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgc3VnZ2VzdGlvbnM6IHByZXYuc3VnZ2VzdGlvbnMubWFwKHMgPT5cbiAgICAgICAgcy5pZCA9PT0gaWRcbiAgICAgICAgICA/IHsgLi4ucywgZGVjaXNpb24sIG5vdGVzOiBub3RlcyB8fCBzLm5vdGVzIH1cbiAgICAgICAgICA6IHNcbiAgICAgICksXG4gICAgfSkpO1xuICB9LCBbdXBkYXRlU3RhdGVdKTtcblxuICAvLyBVcGRhdGUgc3VnZ2VzdGlvblxuICBjb25zdCB1cGRhdGVTdWdnZXN0aW9uID0gdXNlQ2FsbGJhY2soKGlkOiBzdHJpbmcsIHVwZGF0ZXM6IFBhcnRpYWw8U3VnZ2VzdGlvbkNhcmREYXRhPikgPT4ge1xuICAgIHVwZGF0ZVN0YXRlKHByZXYgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICBzdWdnZXN0aW9uczogcHJldi5zdWdnZXN0aW9ucy5tYXAocyA9PlxuICAgICAgICBzLmlkID09PSBpZCA/IHsgLi4ucywgLi4udXBkYXRlcyB9IDogc1xuICAgICAgKSxcbiAgICB9KSk7XG4gIH0sIFt1cGRhdGVTdGF0ZV0pO1xuXG4gIC8vIFJlbW92ZSBzdWdnZXN0aW9uXG4gIGNvbnN0IHJlbW92ZVN1Z2dlc3Rpb24gPSB1c2VDYWxsYmFjaygoaWQ6IHN0cmluZykgPT4ge1xuICAgIHVwZGF0ZVN0YXRlKHByZXYgPT4gKHtcbiAgICAgIC4uLnByZXYsXG4gICAgICBzdWdnZXN0aW9uczogcHJldi5zdWdnZXN0aW9ucy5maWx0ZXIocyA9PiBzLmlkICE9PSBpZCksXG4gICAgfSkpO1xuICB9LCBbdXBkYXRlU3RhdGVdKTtcblxuICAvLyBDbGVhciBhbGwgc3VnZ2VzdGlvbnNcbiAgY29uc3QgY2xlYXJTdWdnZXN0aW9ucyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICB1cGRhdGVTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgc3VnZ2VzdGlvbnM6IFtdLFxuICAgIH0pKTtcbiAgfSwgW3VwZGF0ZVN0YXRlXSk7XG5cbiAgLy8gUmVzZXQgdG8gbmV3IHNlc3Npb25cbiAgY29uc3Qgc3RhcnROZXdTZXNzaW9uID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIC8vIFNhdmUgY3VycmVudCBzZXNzaW9uIHRvIGhpc3RvcnlcbiAgICBjb25zdCBjdXJyZW50U2Vzc2lvbjogQnJhaW5zdG9ybVNlc3Npb24gPSB7XG4gICAgICBpZDogc3RhdGUuc2Vzc2lvbklkLFxuICAgICAgc3RhdGUsXG4gICAgICBjb252ZXJzYXRpb25IaXN0b3J5OiBbXSwgLy8gV291bGQgbmVlZCB0byBiZSBwYXNzZWQgaW5cbiAgICB9O1xuICAgIHNhdmVTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKTtcblxuICAgIC8vIENyZWF0ZSBuZXcgc2Vzc2lvblxuICAgIGNvbnN0IG5ld1N0YXRlID0gY3JlYXRlSW5pdGlhbFN0YXRlKCk7XG4gICAgc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgIHNhdmVTdGF0ZShuZXdTdGF0ZSk7XG4gIH0sIFtzdGF0ZV0pO1xuXG4gIC8vIExvYWQgYSBwcmV2aW91cyBzZXNzaW9uXG4gIGNvbnN0IGxvYWRTZXNzaW9uID0gdXNlQ2FsbGJhY2soKHNlc3Npb25JZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3Qgc2Vzc2lvbnMgPSBsb2FkU2Vzc2lvbnMoKTtcbiAgICBjb25zdCBzZXNzaW9uID0gc2Vzc2lvbnMuZmluZChzID0+IHMuaWQgPT09IHNlc3Npb25JZCk7XG4gICAgXG4gICAgaWYgKHNlc3Npb24pIHtcbiAgICAgIHNldFN0YXRlKHNlc3Npb24uc3RhdGUpO1xuICAgICAgc2F2ZVN0YXRlKHNlc3Npb24uc3RhdGUpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIEV4cG9ydCBjdXJyZW50IHN0YXRlIGFzIG1hcmtkb3duXG4gIGNvbnN0IGV4cG9ydEhpc3RvcnkgPSB1c2VDYWxsYmFjayhhc3luYyAoKTogUHJvbWlzZTxzdHJpbmc+ID0+IHtcbiAgICBjb25zdCB7IHN1Z2dlc3Rpb25zLCBzZXNzaW9uSWQsIHN0YXJ0ZWRBdCwgbWV0YWRhdGEgfSA9IHN0YXRlO1xuICAgIFxuICAgIGxldCBtYXJrZG93biA9IGAjIEJyYWluc3Rvcm0gU2Vzc2lvbiBSZXBvcnRcXG5cXG5gO1xuICAgIG1hcmtkb3duICs9IGAqKlNlc3Npb24gSUQ6KiogJHtzZXNzaW9uSWR9XFxuYDtcbiAgICBtYXJrZG93biArPSBgKipTdGFydGVkOioqICR7c3RhcnRlZEF0LnRvTG9jYWxlU3RyaW5nKCl9XFxuYDtcbiAgICBtYXJrZG93biArPSBgKipMYXN0IFVwZGF0ZWQ6KiogJHtzdGF0ZS5sYXN0VXBkYXRlZC50b0xvY2FsZVN0cmluZygpfVxcblxcbmA7XG5cbiAgICAvLyBTdW1tYXJ5XG4gICAgbWFya2Rvd24gKz0gYCMjIFN1bW1hcnlcXG5cXG5gO1xuICAgIG1hcmtkb3duICs9IGAtICoqVG90YWwgU3VnZ2VzdGlvbnM6KiogJHttZXRhZGF0YS50b3RhbFN1Z2dlc3Rpb25zfVxcbmA7XG4gICAgbWFya2Rvd24gKz0gYC0gKipBY2NlcHRlZDoqKiAke21ldGFkYXRhLmFjY2VwdGVkQ291bnR9XFxuYDtcbiAgICBtYXJrZG93biArPSBgLSAqKlJlamVjdGVkOioqICR7bWV0YWRhdGEucmVqZWN0ZWRDb3VudH1cXG5gO1xuICAgIG1hcmtkb3duICs9IGAtICoqRGVmZXJyZWQ6KiogJHttZXRhZGF0YS5kZWZlcnJlZENvdW50fVxcbmA7XG4gICAgbWFya2Rvd24gKz0gYC0gKipQZW5kaW5nOioqICR7bWV0YWRhdGEudG90YWxTdWdnZXN0aW9ucyAtIG1ldGFkYXRhLmFjY2VwdGVkQ291bnQgLSBtZXRhZGF0YS5yZWplY3RlZENvdW50IC0gbWV0YWRhdGEuZGVmZXJyZWRDb3VudH1cXG5cXG5gO1xuXG4gICAgLy8gQ2F0ZWdvcmllcyBicmVha2Rvd25cbiAgICBtYXJrZG93biArPSBgIyMjIENhdGVnb3JpZXNcXG5cXG5gO1xuICAgIE9iamVjdC5lbnRyaWVzKG1ldGFkYXRhLmNhdGVnb3JpZXMpLmZvckVhY2goKFtjYXRlZ29yeSwgY291bnRdKSA9PiB7XG4gICAgICBtYXJrZG93biArPSBgLSAqKiR7Y2F0ZWdvcnkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjYXRlZ29yeS5zbGljZSgxKX06KiogJHtjb3VudH1cXG5gO1xuICAgIH0pO1xuICAgIG1hcmtkb3duICs9IGBcXG5gO1xuXG4gICAgLy8gRGVjaXNpb25zIHRhYmxlXG4gICAgbWFya2Rvd24gKz0gYCMjIERlY2lzaW9uc1xcblxcbmA7XG4gICAgbWFya2Rvd24gKz0gYHwgVGl0bGUgfCBDYXRlZ29yeSB8IERlY2lzaW9uIHwgSW1wYWN0IHwgQ29uZmlkZW5jZSB8IEVmZm9ydCB8IE5vdGVzIHxcXG5gO1xuICAgIG1hcmtkb3duICs9IGB8LS0tLS0tLXwtLS0tLS0tLS0tfC0tLS0tLS0tLS18LS0tLS0tLS18LS0tLS0tLS0tLS0tfC0tLS0tLS0tfC0tLS0tLS18XFxuYDtcbiAgICBcbiAgICBzdWdnZXN0aW9ucy5mb3JFYWNoKHN1Z2dlc3Rpb24gPT4ge1xuICAgICAgY29uc3QgZGVjaXNpb24gPSBzdWdnZXN0aW9uLmRlY2lzaW9uIHx8ICdwZW5kaW5nJztcbiAgICAgIGNvbnN0IG5vdGVzID0gc3VnZ2VzdGlvbi5ub3RlcyA/IHN1Z2dlc3Rpb24ubm90ZXMucmVwbGFjZSgvXFxuL2csICcgJykuc3Vic3RyaW5nKDAsIDUwKSArICcuLi4nIDogJyc7XG4gICAgICBtYXJrZG93biArPSBgfCAke3N1Z2dlc3Rpb24udGl0bGV9IHwgJHtzdWdnZXN0aW9uLmNhdGVnb3J5fSB8ICR7ZGVjaXNpb259IHwgJHtzdWdnZXN0aW9uLmltcGFjdF9zY29yZX0vMTAgfCAke01hdGgucm91bmQoc3VnZ2VzdGlvbi5jb25maWRlbmNlICogMTAwKX0lIHwgJHtzdWdnZXN0aW9uLmltcGxlbWVudGF0aW9uX2VmZm9ydH0gfCAke25vdGVzfSB8XFxuYDtcbiAgICB9KTtcbiAgICBtYXJrZG93biArPSBgXFxuYDtcblxuICAgIC8vIEFjY2VwdGVkIHN1Z2dlc3Rpb25zIGRldGFpbFxuICAgIGNvbnN0IGFjY2VwdGVkID0gc3VnZ2VzdGlvbnMuZmlsdGVyKHMgPT4gcy5kZWNpc2lvbiA9PT0gJ2FjY2VwdGVkJyk7XG4gICAgaWYgKGFjY2VwdGVkLmxlbmd0aCA+IDApIHtcbiAgICAgIG1hcmtkb3duICs9IGAjIyBBY2NlcHRlZCBTdWdnZXN0aW9uc1xcblxcbmA7XG4gICAgICBhY2NlcHRlZC5mb3JFYWNoKChzdWdnZXN0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICBtYXJrZG93biArPSBgIyMjICR7aW5kZXggKyAxfS4gJHtzdWdnZXN0aW9uLnRpdGxlfVxcblxcbmA7XG4gICAgICAgIG1hcmtkb3duICs9IGAqKkNhdGVnb3J5OioqICR7c3VnZ2VzdGlvbi5jYXRlZ29yeX1cXG5gO1xuICAgICAgICBtYXJrZG93biArPSBgKipJbXBhY3QgU2NvcmU6KiogJHtzdWdnZXN0aW9uLmltcGFjdF9zY29yZX0vMTBcXG5gO1xuICAgICAgICBtYXJrZG93biArPSBgKipDb25maWRlbmNlOioqICR7TWF0aC5yb3VuZChzdWdnZXN0aW9uLmNvbmZpZGVuY2UgKiAxMDApfSVcXG5gO1xuICAgICAgICBtYXJrZG93biArPSBgKipJbXBsZW1lbnRhdGlvbiBFZmZvcnQ6KiogJHtzdWdnZXN0aW9uLmltcGxlbWVudGF0aW9uX2VmZm9ydH1cXG5cXG5gO1xuICAgICAgICBtYXJrZG93biArPSBgKipTdW1tYXJ5OioqICR7c3VnZ2VzdGlvbi5zdW1tYXJ5fVxcblxcbmA7XG4gICAgICAgIG1hcmtkb3duICs9IGAqKlJlYXNvbmluZzoqKiAke3N1Z2dlc3Rpb24ucmVhc29uaW5nfVxcblxcbmA7XG4gICAgICAgIFxuICAgICAgICBpZiAoc3VnZ2VzdGlvbi5kZXBlbmRlbmNpZXMgJiYgc3VnZ2VzdGlvbi5kZXBlbmRlbmNpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG1hcmtkb3duICs9IGAqKkRlcGVuZGVuY2llczoqKlxcbmA7XG4gICAgICAgICAgc3VnZ2VzdGlvbi5kZXBlbmRlbmNpZXMuZm9yRWFjaChkZXAgPT4ge1xuICAgICAgICAgICAgbWFya2Rvd24gKz0gYC0gJHtkZXB9XFxuYDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtYXJrZG93biArPSBgXFxuYDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHN1Z2dlc3Rpb24ubWV0cmljcyAmJiBzdWdnZXN0aW9uLm1ldHJpY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG1hcmtkb3duICs9IGAqKlN1Y2Nlc3MgTWV0cmljczoqKlxcbmA7XG4gICAgICAgICAgc3VnZ2VzdGlvbi5tZXRyaWNzLmZvckVhY2gobWV0cmljID0+IHtcbiAgICAgICAgICAgIG1hcmtkb3duICs9IGAtICR7bWV0cmljfVxcbmA7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbWFya2Rvd24gKz0gYFxcbmA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChzdWdnZXN0aW9uLnJpc2tzICYmIHN1Z2dlc3Rpb24ucmlza3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG1hcmtkb3duICs9IGAqKlJpc2tzOioqXFxuYDtcbiAgICAgICAgICBzdWdnZXN0aW9uLnJpc2tzLmZvckVhY2gocmlzayA9PiB7XG4gICAgICAgICAgICBtYXJrZG93biArPSBgLSAke3Jpc2t9XFxuYDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtYXJrZG93biArPSBgXFxuYDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHN1Z2dlc3Rpb24ubm90ZXMpIHtcbiAgICAgICAgICBtYXJrZG93biArPSBgKipOb3RlczoqKiAke3N1Z2dlc3Rpb24ubm90ZXN9XFxuXFxuYDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbWFya2Rvd24gKz0gYC0tLVxcblxcbmA7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBNYXJrIHNlc3Npb24gYXMgZXhwb3J0ZWRcbiAgICB1cGRhdGVTdGF0ZShwcmV2ID0+IHByZXYpO1xuICAgIGNvbnN0IHNlc3Npb246IEJyYWluc3Rvcm1TZXNzaW9uID0ge1xuICAgICAgaWQ6IHNlc3Npb25JZCxcbiAgICAgIHN0YXRlLFxuICAgICAgY29udmVyc2F0aW9uSGlzdG9yeTogW10sXG4gICAgICBleHBvcnRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgIH07XG4gICAgc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG5cbiAgICByZXR1cm4gbWFya2Rvd247XG4gIH0sIFtzdGF0ZSwgdXBkYXRlU3RhdGVdKTtcblxuICAvLyBHZXQgZmlsdGVyZWQgc3VnZ2VzdGlvbnNcbiAgY29uc3QgZ2V0RmlsdGVyZWRTdWdnZXN0aW9ucyA9IHVzZUNhbGxiYWNrKChmaWx0ZXJzOiB7XG4gICAgY2F0ZWdvcnk/OiBzdHJpbmc7XG4gICAgZGVjaXNpb24/OiBzdHJpbmc7XG4gICAgbWluSW1wYWN0PzogbnVtYmVyO1xuICAgIG1heEltcGFjdD86IG51bWJlcjtcbiAgfSkgPT4ge1xuICAgIHJldHVybiBzdGF0ZS5zdWdnZXN0aW9ucy5maWx0ZXIoc3VnZ2VzdGlvbiA9PiB7XG4gICAgICBpZiAoZmlsdGVycy5jYXRlZ29yeSAmJiBzdWdnZXN0aW9uLmNhdGVnb3J5ICE9PSBmaWx0ZXJzLmNhdGVnb3J5KSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoZmlsdGVycy5kZWNpc2lvbiAmJiBzdWdnZXN0aW9uLmRlY2lzaW9uICE9PSBmaWx0ZXJzLmRlY2lzaW9uKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoZmlsdGVycy5taW5JbXBhY3QgJiYgc3VnZ2VzdGlvbi5pbXBhY3Rfc2NvcmUgPCBmaWx0ZXJzLm1pbkltcGFjdCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGZpbHRlcnMubWF4SW1wYWN0ICYmIHN1Z2dlc3Rpb24uaW1wYWN0X3Njb3JlID4gZmlsdGVycy5tYXhJbXBhY3QpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9LCBbc3RhdGUuc3VnZ2VzdGlvbnNdKTtcblxuICAvLyBHZXQgc2Vzc2lvbiBoaXN0b3J5XG4gIGNvbnN0IGdldFNlc3Npb25IaXN0b3J5ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHJldHVybiBsb2FkU2Vzc2lvbnMoKTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiB7XG4gICAgc3RhdGUsXG4gICAgaXNMb2FkaW5nLFxuICAgIGFkZFN1Z2dlc3Rpb24sXG4gICAgdXBkYXRlRGVjaXNpb24sXG4gICAgdXBkYXRlU3VnZ2VzdGlvbixcbiAgICByZW1vdmVTdWdnZXN0aW9uLFxuICAgIGNsZWFyU3VnZ2VzdGlvbnMsXG4gICAgc3RhcnROZXdTZXNzaW9uLFxuICAgIGxvYWRTZXNzaW9uLFxuICAgIGV4cG9ydEhpc3RvcnksXG4gICAgZ2V0RmlsdGVyZWRTdWdnZXN0aW9ucyxcbiAgICBnZXRTZXNzaW9uSGlzdG9yeSxcbiAgfTtcbn07XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsIlNUT1JBR0VfS0VZIiwiU0VTU0lPTlNfS0VZIiwiY3JlYXRlSW5pdGlhbFN0YXRlIiwic3VnZ2VzdGlvbnMiLCJzZXNzaW9uSWQiLCJNYXRoIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwic3RhcnRlZEF0IiwibGFzdFVwZGF0ZWQiLCJtZXRhZGF0YSIsInRvdGFsU3VnZ2VzdGlvbnMiLCJhY2NlcHRlZENvdW50IiwicmVqZWN0ZWRDb3VudCIsImRlZmVycmVkQ291bnQiLCJjYXRlZ29yaWVzIiwiY2FsY3VsYXRlTWV0YWRhdGEiLCJsZW5ndGgiLCJmb3JFYWNoIiwic3VnZ2VzdGlvbiIsImRlY2lzaW9uIiwiY2F0ZWdvcnkiLCJzYXZlU3RhdGUiLCJzdGF0ZSIsInNlcmlhbGl6ZWQiLCJ0b0lTT1N0cmluZyIsIm1hcCIsInMiLCJjcmVhdGVkX2F0IiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcnJvciIsImNvbnNvbGUiLCJsb2FkU3RhdGUiLCJzYXZlZCIsImdldEl0ZW0iLCJwYXJzZWQiLCJwYXJzZSIsInNhdmVTZXNzaW9uIiwic2Vzc2lvbiIsInNlc3Npb25zIiwibG9hZFNlc3Npb25zIiwiZXhpc3RpbmdJbmRleCIsImZpbmRJbmRleCIsImlkIiwicHVzaCIsInJlY2VudFNlc3Npb25zIiwic2xpY2UiLCJleHBvcnRlZEF0IiwidW5kZWZpbmVkIiwic3luY1dpdGhTdXBhYmFzZSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIm9rIiwid2FybiIsInN0YXR1c1RleHQiLCJ1c2VCcmFpbnN0b3JtU3RhdGUiLCJzZXRTdGF0ZSIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImxvYWRlZFN0YXRlIiwidXBkYXRlU3RhdGUiLCJ1cGRhdGVyIiwicHJldiIsIm5ld1N0YXRlIiwic3RhdGVXaXRoTWV0YWRhdGEiLCJhZGRTdWdnZXN0aW9uIiwidXBkYXRlRGVjaXNpb24iLCJub3RlcyIsInVwZGF0ZVN1Z2dlc3Rpb24iLCJ1cGRhdGVzIiwicmVtb3ZlU3VnZ2VzdGlvbiIsImZpbHRlciIsImNsZWFyU3VnZ2VzdGlvbnMiLCJzdGFydE5ld1Nlc3Npb24iLCJjdXJyZW50U2Vzc2lvbiIsImNvbnZlcnNhdGlvbkhpc3RvcnkiLCJsb2FkU2Vzc2lvbiIsImZpbmQiLCJleHBvcnRIaXN0b3J5IiwibWFya2Rvd24iLCJ0b0xvY2FsZVN0cmluZyIsIk9iamVjdCIsImVudHJpZXMiLCJjb3VudCIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwicmVwbGFjZSIsInN1YnN0cmluZyIsInRpdGxlIiwiaW1wYWN0X3Njb3JlIiwicm91bmQiLCJjb25maWRlbmNlIiwiaW1wbGVtZW50YXRpb25fZWZmb3J0IiwiYWNjZXB0ZWQiLCJpbmRleCIsInN1bW1hcnkiLCJyZWFzb25pbmciLCJkZXBlbmRlbmNpZXMiLCJkZXAiLCJtZXRyaWNzIiwibWV0cmljIiwicmlza3MiLCJyaXNrIiwiZ2V0RmlsdGVyZWRTdWdnZXN0aW9ucyIsImZpbHRlcnMiLCJtaW5JbXBhY3QiLCJtYXhJbXBhY3QiLCJnZXRTZXNzaW9uSGlzdG9yeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/brainstorm/state.ts\n"));

/***/ })

});